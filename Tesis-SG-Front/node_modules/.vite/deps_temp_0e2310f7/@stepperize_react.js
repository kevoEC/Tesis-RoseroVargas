import {
  require_react
} from "./chunk-VQORH22F.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@stepperize/react/dist/index.js
var e2 = __toESM(require_react());

// node_modules/@stepperize/core/dist/index.js
function e(...e3) {
  return { getAll: () => e3, get: (n2) => e3.find((e4) => e4.id === n2), getIndex: (n2) => e3.findIndex((e4) => e4.id === n2), getByIndex: (n2) => e3[n2], getFirst: () => e3[0], getLast: () => e3[e3.length - 1], getNext: (n2) => e3[e3.findIndex((e4) => e4.id === n2) + 1], getPrev: (n2) => e3[e3.findIndex((e4) => e4.id === n2) - 1], getNeighbors(n2) {
    const t2 = e3.findIndex((e4) => e4.id === n2);
    return { prev: t2 > 0 ? e3[t2 - 1] : null, next: t2 < e3.length - 1 ? e3[t2 + 1] : null };
  } };
}
function n(e3, n2) {
  return Math.max(e3.findIndex((e4) => e4.id === n2), 0);
}
function t(e3, n2) {
  return e3.reduce((e4, t2) => (e4[t2.id] = (n2 == null ? void 0 : n2[t2.id]) ?? null, e4), {});
}
function r(e3, n2, t2) {
  return { switch(e4) {
    const t3 = e4[n2.id];
    return t3 == null ? void 0 : t3(n2);
  }, when(n3, r2, i2) {
    const d2 = e3[t2];
    return (Array.isArray(n3) ? d2.id === n3[0] && n3.slice(1).every(Boolean) : d2.id === n3) ? r2 == null ? void 0 : r2(d2) : i2 == null ? void 0 : i2(d2);
  }, match(n3, r2) {
    const i2 = e3[t2], d2 = e3.find((e4) => e4.id === n3);
    if ((d2 == null ? void 0 : d2.id) === i2.id) {
      const e4 = r2[n3];
      return e4 == null ? void 0 : e4(d2);
    }
    return null;
  } };
}
async function i(e3, n2) {
  const t2 = await e3();
  return !n2 || true === t2;
}
var d = async ({ stepper: e3, direction: n2, callback: t2, before: r2, targetId: d2 }) => {
  (!r2 || await i(t2, true)) && ("next" === n2 ? e3.next() : "prev" === n2 ? e3.prev() : "goTo" === n2 && d2 && e3.goTo(d2), r2 || await i(t2, false));
};
var o = (e3, n2, t2) => {
  n2 < 0 && s({ steps: e3, newIndex: n2, direction: "next", reason: "it is the first step" }), n2 >= e3.length && s({ steps: e3, newIndex: n2, direction: "prev", reason: "it is the last step" }), t2(n2);
};
var s = ({ steps: e3, newIndex: n2, direction: t2, reason: r2 }) => {
  throw new Error(`Cannot navigate ${t2} from step "${e3[n2].id}": ${r2}`);
};

// node_modules/@stepperize/react/dist/index.js
var s2 = (...s3) => {
  const c = e2.createContext(null), p = e(...s3), l = (t2) => {
    const { initialStep: c2, initialMetadata: p2 } = t2 ?? {}, l2 = e2.useMemo(() => n(s3, c2), [c2]), [d2, f] = e2.useState(l2), [b, u] = e2.useState(() => t(s3, p2)), v = e2.useMemo(() => {
      const e3 = s3[d2], t3 = d2 === s3.length - 1;
      return { all: s3, current: e3, isLast: t3, isFirst: 0 === d2, metadata: b, setMetadata(e4, t4) {
        u((a) => a[e4] === t4 ? a : { ...a, [e4]: t4 });
      }, getMetadata: (e4) => b[e4], resetMetadata(e4) {
        u(t(s3, e4 ? p2 : void 0));
      }, next() {
        o(s3, d2 + 1, (e4) => {
          f(e4);
        });
      }, prev() {
        o(s3, d2 - 1, (e4) => {
          f(e4);
        });
      }, get: (e4) => s3.find((t4) => t4.id === e4), goTo(e4) {
        const t4 = s3.findIndex((t5) => t5.id === e4);
        if (-1 === t4) throw new Error(`Step with id "${e4}" not found.`);
        o(s3, t4, (e5) => {
          f(e5);
        });
      }, reset() {
        o(s3, n(s3, c2), (e4) => {
          f(e4);
        });
      }, async beforeNext(e4) {
        await d({ stepper: v, direction: "next", callback: e4, before: true });
      }, async afterNext(e4) {
        this.next(), await d({ stepper: v, direction: "next", callback: e4, before: false });
      }, async beforePrev(e4) {
        await d({ stepper: v, direction: "prev", callback: e4, before: true });
      }, async afterPrev(e4) {
        this.prev(), await d({ stepper: v, direction: "prev", callback: e4, before: false });
      }, async beforeGoTo(e4, t4) {
        await d({ stepper: v, direction: "goTo", callback: t4, before: true, targetId: e4 });
      }, async afterGoTo(e4, t4) {
        this.goTo(e4), await d({ stepper: v, direction: "goTo", callback: t4, before: false, targetId: e4 });
      }, ...r(s3, e3, d2) };
    }, [d2, b]);
    return v;
  };
  return { steps: s3, utils: p, Scoped: ({ initialStep: t2, initialMetadata: a, children: r2 }) => e2.createElement(c.Provider, { value: l({ initialStep: t2, initialMetadata: a }) }, r2), useStepper: (t2 = {}) => e2.useContext(c) ?? l(t2) };
};
export {
  s2 as defineStepper
};
//# sourceMappingURL=@stepperize_react.js.map
