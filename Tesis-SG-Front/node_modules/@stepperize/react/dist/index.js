import*as e from"react";import{generateStepperUtils as t,getInitialStepIndex as a,getInitialMetadata as r,generateCommonStepperUseFns as i,executeTransition as o,updateStepIndex as n}from"@stepperize/core";var s=(...s)=>{const c=e.createContext(null),p=t(...s),l=t=>{const{initialStep:c,initialMetadata:p}=t??{},l=e.useMemo((()=>a(s,c)),[c]),[d,f]=e.useState(l),[b,u]=e.useState((()=>r(s,p))),v=e.useMemo((()=>{const e=s[d],t=d===s.length-1;return{all:s,current:e,isLast:t,isFirst:0===d,metadata:b,setMetadata(e,t){u((a=>a[e]===t?a:{...a,[e]:t}))},getMetadata:e=>b[e],resetMetadata(e){u(r(s,e?p:void 0))},next(){n(s,d+1,(e=>{f(e)}))},prev(){n(s,d-1,(e=>{f(e)}))},get:e=>s.find((t=>t.id===e)),goTo(e){const t=s.findIndex((t=>t.id===e));if(-1===t)throw new Error(`Step with id "${e}" not found.`);n(s,t,(e=>{f(e)}))},reset(){n(s,a(s,c),(e=>{f(e)}))},async beforeNext(e){await o({stepper:v,direction:"next",callback:e,before:!0})},async afterNext(e){this.next(),await o({stepper:v,direction:"next",callback:e,before:!1})},async beforePrev(e){await o({stepper:v,direction:"prev",callback:e,before:!0})},async afterPrev(e){this.prev(),await o({stepper:v,direction:"prev",callback:e,before:!1})},async beforeGoTo(e,t){await o({stepper:v,direction:"goTo",callback:t,before:!0,targetId:e})},async afterGoTo(e,t){this.goTo(e),await o({stepper:v,direction:"goTo",callback:t,before:!1,targetId:e})},...i(s,e,d)}}),[d,b]);return v};return{steps:s,utils:p,Scoped:({initialStep:t,initialMetadata:a,children:r})=>e.createElement(c.Provider,{value:l({initialStep:t,initialMetadata:a})},r),useStepper:(t={})=>e.useContext(c)??l(t)}};export{s as defineStepper};