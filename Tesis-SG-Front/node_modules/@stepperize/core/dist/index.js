function e(...e){return{getAll:()=>e,get:n=>e.find((e=>e.id===n)),getIndex:n=>e.findIndex((e=>e.id===n)),getByIndex:n=>e[n],getFirst:()=>e[0],getLast:()=>e[e.length-1],getNext:n=>e[e.findIndex((e=>e.id===n))+1],getPrev:n=>e[e.findIndex((e=>e.id===n))-1],getNeighbors(n){const t=e.findIndex((e=>e.id===n));return{prev:t>0?e[t-1]:null,next:t<e.length-1?e[t+1]:null}}}}function n(e,n){return Math.max(e.findIndex((e=>e.id===n)),0)}function t(e,n){return e.reduce(((e,t)=>(e[t.id]=n?.[t.id]??null,e)),{})}function r(e,n,t){return{switch(e){const t=e[n.id];return t?.(n)},when(n,r,i){const d=e[t];return(Array.isArray(n)?d.id===n[0]&&n.slice(1).every(Boolean):d.id===n)?r?.(d):i?.(d)},match(n,r){const i=e[t],d=e.find((e=>e.id===n));if(d?.id===i.id){const e=r[n];return e?.(d)}return null}}}async function i(e,n){const t=await e();return!n||!0===t}var d=async({stepper:e,direction:n,callback:t,before:r,targetId:d})=>{(!r||await i(t,!0))&&("next"===n?e.next():"prev"===n?e.prev():"goTo"===n&&d&&e.goTo(d),r||await i(t,!1))},o=(e,n,t)=>{n<0&&s({steps:e,newIndex:n,direction:"next",reason:"it is the first step"}),n>=e.length&&s({steps:e,newIndex:n,direction:"prev",reason:"it is the last step"}),t(n)},s=({steps:e,newIndex:n,direction:t,reason:r})=>{throw new Error(`Cannot navigate ${t} from step "${e[n].id}": ${r}`)};export{d as executeTransition,r as generateCommonStepperUseFns,e as generateStepperUtils,t as getInitialMetadata,n as getInitialStepIndex,o as updateStepIndex};