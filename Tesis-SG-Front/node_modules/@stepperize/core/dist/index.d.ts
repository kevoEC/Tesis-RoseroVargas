type Step = {
    id: string;
} & Record<string, any>;
type Metadata = Record<string, any> | null;
type Stepper<Steps extends Step[] = Step[]> = {
    /** Returns all steps. */
    all: Steps;
    /** Returns the current step. */
    current: Steps[number];
    /** Returns true if the current step is the last step. */
    isLast: boolean;
    /** Returns true if the current step is the first step. */
    isFirst: boolean;
    /** Advances to the next step. */
    next: () => void;
    /** Returns to the previous step. */
    prev: () => void;
    /** Returns a step by its ID. */
    get: <Id extends Get.Id<Steps>>(id: Id) => Get.StepById<Steps, Id>;
    /** Navigates to a specific step by its ID. */
    goTo: (id: Get.Id<Steps>) => void;
    /** Resets the stepper to its initial state. */
    reset: () => void;
    /** Executes a function before navigating to the next step. */
    beforeNext: (callback: () => Promise<boolean> | boolean) => Promise<void> | void;
    /** Executes a function after navigating to the next step. */
    afterNext: (callback: () => Promise<void> | void) => Promise<void> | void;
    /** Executes a function before navigating to the previous step. */
    beforePrev: (callback: () => Promise<boolean> | boolean) => Promise<void> | void;
    /** Executes a function after navigating to the previous step. */
    afterPrev: (callback: () => Promise<void> | void) => Promise<void> | void;
    /** Executes a function before navigating to a specific step. */
    beforeGoTo: (id: Get.Id<Steps>, callback: () => Promise<boolean> | boolean) => Promise<void> | void;
    /** Executes a function after navigating to a specific step. */
    afterGoTo: (id: Get.Id<Steps>, callback: () => Promise<void> | void) => Promise<void> | void;
    /**
     * Executes a function based on the current step ID.
     * @param id - The ID of the step to check.
     * @param whenFn - Function to execute if the current step matches the ID.
     * @param elseFn - Optional function to execute if the current step does not match the ID.
     * @returns The result of whenFn or elseFn.
     */
    when: <Id extends Get.Id<Steps>, R1, R2>(id: Id | [Id, ...boolean[]], whenFn: (step: Get.StepById<Steps, Id>) => R1, elseFn?: (step: Get.StepSansId<Steps, Id>) => R2) => R1 | R2;
    /**
     * Executes a function based on a switch-case-like structure for steps.
     * @param when - An object mapping step IDs to functions.
     * @returns The result of the function corresponding to the current step ID.
     */
    switch: <R>(when: Get.Switch<Steps, R>) => R;
    /**
     * Matches the current state with a set of possible states and executes the corresponding function.
     * @param state - The current state ID.
     * @param matches - An object mapping state IDs to functions.
     * @returns The result of the matched function or null if no match is found.
     */
    match: <State extends Get.Id<Steps>, R>(state: State, matches: Get.Switch<Steps, R>) => R | null;
    /**
     * Retrieves the metadata for the current step.
     * @returns The metadata for the current step.
     */
    metadata: Record<Get.Id<Steps>, Metadata>;
    /**
     * Sets the metadata for a step.
     * @param id - The ID of the step to set the metadata for.
     * @param values - The values to set for the metadata.
     */
    setMetadata: <M extends Metadata>(id: Get.Id<Steps>, values: M) => void;
    /**
     * Get the metadata for a step.
     * @param id - The ID of the step to get the metadata for.
     * @returns The metadata for the step.
     */
    getMetadata: <M extends Metadata>(id: Get.Id<Steps>) => M;
    /**
     * Resets the metadata to the initial state.
     * @param keepInitialMetadata - If true, the initial metadata defined in the useStepper hook will be kept.
     */
    resetMetadata: (keepInitialMetadata?: boolean) => void;
};
type Utils<Steps extends Step[] = Step[]> = {
    /**
     * Retrieves all steps.
     * @returns An array of all steps.
     */
    getAll: () => Steps;
    /**
     * Retrieves a step by its ID.
     * @param id - The ID of the step to retrieve.
     * @returns The step with the specified ID.
     */
    get: <Id extends Get.Id<Steps>>(id: Id) => Get.StepById<Steps, Id>;
    /**
     * Retrieves the index of a step by its ID.
     * @param id - The ID of the step to retrieve the index for.
     * @returns The index of the step.
     */
    getIndex: <Id extends Get.Id<Steps>>(id: Id) => number;
    /**
     * Retrieves a step by its index.
     * @param index - The index of the step to retrieve.
     * @returns The step at the specified index.
     */
    getByIndex: <Index extends number>(index: Index) => Steps[Index];
    /**
     * Retrieves the first step.
     * @returns The first step.
     */
    getFirst: () => Steps[number];
    /**
     * Retrieves the last step.
     * @returns The last step.
     */
    getLast: () => Steps[number];
    /**
     * Retrieves the next step after the specified ID.
     * @param id - The ID of the current step.
     * @returns The next step.
     */
    getNext: <Id extends Get.Id<Steps>>(id: Id) => Steps[number];
    /**
     * Retrieves the previous step before the specified ID.
     * @param id - The ID of the current step.
     * @returns The previous step.
     */
    getPrev: <Id extends Get.Id<Steps>>(id: Id) => Steps[number];
    /**
     * Retrieves the neighboring steps (previous and next) of the specified step.
     * @param id - The ID of the current step.
     * @returns An object containing the previous and next steps.
     */
    getNeighbors: <Id extends Get.Id<Steps>>(id: Id) => {
        prev: Steps[number] | null;
        next: Steps[number] | null;
    };
};
declare namespace Get {
    /** Returns a union of possible IDs from the given Steps. */
    type Id<Steps extends Step[] = Step[]> = Steps[number]["id"];
    /** Returns a Step from the given Steps with the given Step Id. */
    type StepById<Steps extends Step[], Id extends Get.Id<Steps>> = Extract<Steps[number], {
        id: Id;
    }>;
    /** Returns any Steps from the given Steps without the given Step Id. */
    type StepSansId<Steps extends Step[], Id extends Get.Id<Steps>> = Exclude<Steps[number], {
        id: Id;
    }>;
    /** Returns any Steps from the given Steps without the given Step Id. */
    type Switch<Steps extends Step[], R> = {
        [Id in Get.Id<Steps>]?: (step: Get.StepById<Steps, Id>) => R;
    };
}

/**
 * Generate stepper utils.
 * @param steps - The steps to generate the utils for.
 * @returns The stepper utils.
 */
declare function generateStepperUtils<const Steps extends Step[]>(...steps: Steps): {
    getAll(): Steps;
    get: <Id extends Get.Id<Steps>>(id: Id) => Get.StepById<Steps, typeof id>;
    getIndex: <Id extends Get.Id<Steps>>(id: Id) => number;
    getByIndex: <Index extends number>(index: Index) => Steps[Index];
    getFirst(): Step;
    getLast(): Step;
    getNext<Id extends Get.Id<Steps>>(id: Id): Step;
    getPrev<Id extends Get.Id<Steps>>(id: Id): Step;
    getNeighbors<Id extends Get.Id<Steps>>(id: Id): {
        prev: Step | null;
        next: Step | null;
    };
};
/**
 * Get the initial step index for the stepper.
 * @param steps - The steps to get the initial step index for.
 * @param initialStep - The initial step to use.
 * @returns The initial step index for the stepper.
 */
declare function getInitialStepIndex<Steps extends Step[]>(steps: Steps, initialStep?: Get.Id<Steps>): number;
/**
 * Get the initial metadata for the stepper.
 * @param steps - The steps to get the initial metadata for.
 * @param initialMetadata - The initial metadata to use.
 * @returns The initial metadata for the stepper.
 */
declare function getInitialMetadata<Steps extends Step[]>(steps: Steps, initialMetadata?: Partial<Record<Get.Id<Steps>, Metadata>>): Record<Get.Id<Steps>, Metadata>;
/**
 * Generate common stepper use functions.
 * @param steps - The steps to generate the functions for.
 * @param currentStep - The current step.
 * @param stepIndex - The index of the current step.
 * @returns The common stepper use functions.
 */
declare function generateCommonStepperUseFns<const Steps extends Step[]>(steps: Steps, currentStep: Steps[number], stepIndex: number): Pick<Stepper<Steps>, "switch" | "when" | "match">;
/**
 * This function is used to execute a callback before or after a transition.
 * @param stepper - The stepper to execute the transition for.
 * @param direction - The direction to execute the transition for.
 * @param callback - The callback to execute the transition for.
 * @param before - Whether the callback is before the transition.
 * @param targetId - The target ID to execute the transition for.
 */
declare const executeTransition: <Steps extends Step[]>({ stepper, direction, callback, before, targetId, }: {
    stepper: Stepper<Steps>;
    direction: "next" | "prev" | "goTo";
    callback: (() => Promise<boolean> | boolean) | (() => Promise<void> | void);
    before: boolean;
    targetId?: Get.Id<Steps>;
}) => Promise<void>;
/**
 * Update the step index.
 * @param steps - The steps to update the step index for.
 * @param newIndex - The new index to update the step index to.
 * @param setter - The setter to update the step index with.
 */
declare const updateStepIndex: <Steps extends Step[]>(steps: Steps, newIndex: number, setter: (index: number) => void) => void;

export { Get, type Metadata, type Step, type Stepper, type Utils, executeTransition, generateCommonStepperUseFns, generateStepperUtils, getInitialMetadata, getInitialStepIndex, updateStepIndex };
